#+TITLE: gyokaikyor プロジェクトノート
#+PROPERTY: header-args :exports code :results scalar :session *R:tidyNAS*
#+STARTUP: contents

* 目次                                                                :TOC_3:
- [[#これは何か][これは何か？]]
- [[#レガシーファイル構成を整理する][レガシーファイル構成を整理する]]
  - [[#カタクチyyxlsx][★カタクチYY.xlsx]]
    - [[#ファイルがやっていること][ファイルがやっていること]]
    - [[#問題点][問題点]]
    - [[#解決策][解決策]]
  - [[#各県いわし][各県いわし]]
- [[#ディレクトリの構成][ディレクトリの構成]]
- [[#パッケージの機能][パッケージの機能]]
  - [[#データ目録の生成][データ目録の生成]]
  - [[#データの統合][データの統合]]
  - [[#グラフ描画][グラフ描画]]
  - [[#予報文案テンプレートの生成][予報文案テンプレートの生成]]
- [[#デモ][デモ]]
  - [[#ファイル情報を整備する][ファイル情報を整備する]]
- [[#開発環境の整備][開発環境の整備]]
  - [[#ディレクトリ作成][ディレクトリ作成]]
  - [[#セットアップ][セットアップ]]
  - [[#本バッケージ内部で使用するパッケージ][本バッケージ内部で使用するパッケージ]]
- [[#開発][開発]]
  - [[#各県ファイルの処理概要][各県ファイルの処理概要]]
    - [[#体長][体長]]
    - [[#漁獲量][漁獲量]]
  - [[#どう問題を解くか][どう問題を解くか]]
    - [[#get_topleftkey--flmm][get_topleft(key = "FL(mm)")]]
  - [[#リロード--自動テスト][リロード & 自動テスト]]
  - [[#テストコード][テストコード]]
    - [[#テスト-ファイル名操作][テスト/ ファイル名操作]]
    - [[#テスト-セル位置取得][テスト/ セル位置取得]]
    - [[#テスト-文字列操作][テスト/ 文字列操作]]
  - [[#関数][関数]]
    - [[#ファイル名操作][ファイル名操作]]
    - [[#セル位置取得][セル位置取得]]
    - [[#文字列操作][文字列操作]]
    - [[#計測データ取得][計測データ取得]]
    - [[#整形][整形]]

* これは何か？
漁海況業務のリポジトリ．
主にRのパッケージ開発のコミュニケーション用．

* レガシーファイル構成を整理する
** ★カタクチYY.xlsx
*** ファイルがやっていること
各県の月別体長組成を統合し，
- 東シナ海
- 日本海
- 計
というシートで統合する Excel ファイル．
*** 問題点
- バイナリなのでバージョン管理ができない
- 資源評価と漁海況の両方で使用されるが，両業務で集計方法が異なるので紛らわしい．
*** 解決策
2段階の抽象度（精密測定 & 体長組成）で体長整理する．
- 精密データを提出する県については，県ごとに csv 形式の精密測定データベースを作成する．
- 精密はなく，体長組成データを提出する県については，県ごとにcsv 型式の体長組成データベースを作成する．
- 精密・体長各データベースから範囲を指定して体長階級×月形式のテーブルを作成できるようにする．

使用イメージ
#+BEGIN_SRC R :exports code :results silent
kumamoto    <- fmt_bl("./data.git/漁海況/2018年10月/各県資料/熊本県", gyokaikyo = TRUE, plot = TRUE)
db_kumamoto <- read_csv("./output.git/kumamoto_2018oct.csv")
out         <- bind_rows(db_kumamoto, kumamoto)
write.csv(out, "./output.git/kumamoto_2019mar.csv", row.names = FALSE)

get_table("./output.git/nagasaki_2018oct.csv", gyokaikyo = TRUE, start = 2016, end = 2017)
#+END_SRC
**** なぜデータベースか？
過去のデータが報告なしに更新されていた場合に対処するため
**** なぜ県ごとか？
差分管理を確実に実施するため
** 各県いわし
* ディレクトリの構成
通常の R パッケージのディレクトリは全て GitHub で公開する．
ただし，以下のディレクトリは GitHub にはアップロードせず，ローカルで管理する（リモートリポジトリを GitHub ではなく，NAS にする）．
- data.git/: 各県から提供されたデータ．
- docs.git/: 予報文案など．
  
* パッケージの機能
** データ目録の生成
** データの統合
** グラフ描画
- 漁獲量
- 体長組成
** 予報文案テンプレートの生成
何らかの構造化マークアップ言語の形式で．
できるだけタグが短いもの．
マークダウンが有力か？
* デモ
** ファイル情報を整備する
#+BEGIN_SRC R
  library(gyokaikyor)
  library(hash)
  fname  <- c("../data.git/漁海況/2018年3月/各県資料/熊本県/04 【熊本県】H29まき網＆棒受網 体長組成.xlsx",
              "foo")
  prefec <- c("kumamoto",
              "nagasaki")
  tbl_fname <- hash(fname, prefec)

  fname2 <- give_class(fname, tbl_fname)
  fname2[[1]]
  fname2[[2]]

  kumamoto_nested <- fmtbl(fname2[[1]])
  kumamoto        <- fmtbl(fname2[[1]], nest = FALSE)
  nagasaki        <- fmtbl(fname2[[2]])

  kumamoto %>%
    ggplot(aes(bl, fill = as.factor(month))) +
    geom_histogram() +
    facet_grid(month ~ year, scale = "free_y")

#+END_SRC
* 開発環境の整備
** ディレクトリ作成
#+BEGIN_SRC R :results silent
  # getwd()
  # usethis::create_package("gyokaikyor")
#+END_SRC
** セットアップ
#+BEGIN_SRC R :results silent
setwd("gyokaikyor")
#+END_SRC

** 本バッケージ内部で使用するパッケージ
#+BEGIN_SRC R :results silent
  usethis::use_package("magrittr", "Imports")
  usethis::use_package("hash")
  usethis::use_package("tibble")
  usethis::use_package("cellranger")
  usethis::use_package("tinyplyr")
  # usethis::use_package("ggplot2", "Imports")
  # usethis::use_package("tibble", "Imports")
  usethis::use_testthat()
#+END_SRC

#+BEGIN_SRC sh :exports results :session nil
cat gyokaikyor/DESCRIPTION
#+END_SRC

#+RESULTS[26e6d91ffe9c3ff5d95f888fb0006e9154a02abb]:
#+begin_example

Package: gyokaikyor
Title: What the Package Does (One Line, Title Case)
Version: 0.0.0.9000
Authors@R: 
    person(given = "First",
           family = "Last",
           role = c("aut", "cre"),
           email = "first.last@example.com")
Description: What the package does (one paragraph).
License: What license it uses
Encoding: UTF-8
LazyData: true
Imports: 
    magrittr,
    hash,
    tibble
Suggests: 
    testthat
RoxygenNote: 6.1.1
#+end_example

#+BEGIN_SRC sh :exports results :session nil
cat gyokaikyor/NAMESPACE
#+END_SRC

#+RESULTS:
: 
: # Generated by roxygen2: do not edit by hand

* 開発
** 各県ファイルの処理概要
*** 体長
**** まず県別に整理
***** 山口
fresco
***** 福岡
カタクチ測定なし
***** 佐賀
fresco
***** 長崎
- シートを読み込む．対象は春と秋とで違う．
  - 3月漁海況: 2017.09-2018.01小型まき網体長組成.xls
  - 10月漁海況: 2018.02-2018.08小型まき網体長組成.xls
- 漁法名をF2から取得
***** 熊本
列方向に続いた精密測定データ．
10月漁海況のときには前年ファイルも一緒に送ってくれる．
- 04 【熊本県】H29まき網＆棒受網 体長組成.xlsx を開く <- *4月始まり*
- 「カタクチ」シートを読み込み
- df.out を初期化
- 日付が入った列（H29.4.30形式）を取得
- 漁法名を取得
- できればその他情報も取得（操業海域・陸揚げ港）
- 測定データ（全長・被鱗体長・体重）を取得
- df.out を初期化
- 過去のデータベースに df.out を結合
- 重複除去
- 新データベースをkumamoto_2018Oct.csv として書き出し
***** 鹿児島
- 体長組成(H29年度).xlsx を開く　<- *4月始まり*
- 「ｶﾀｸﾁ」シートを読み込み
- 日付が入った列を取得
- 漁法名などの情報を取得
- 個体数情報を体長階級ブロックごと取得
- 過去のdbに結合...
**** まとめると
精密，体長のような分け方はしないほうが良い．
あくまでも，関数を部品として作り，各県ごとにそれを組み合わせて使う．
強いて分類するなら，以下のようになる．
- 精密タイプ: 熊本
- 体長タイプ: 長崎，鹿児島
- fresco タイプ: 山口，佐賀
**** 必要な部品
***** DONE get_cols2load(regex = , offset = )
***** get_top(regex = )
***** get_left(regex = )
***** get_topleft(regex = )
***** get_bottom(regex = )
***** get_right(regex = )
***** get_bottomright(regex = )
***** parse_jpdate(format = )
- 
*** 漁獲量
** どう問題を解くか
県ごとに，どうしてもデータ処理の振る舞いを変える必要がある
そこで， 各県のファイル名に，県名を属性として与える
#+TBLNAME: tbl_fname_prefec
| fname                                    | prefec   |
|------------------------------------------+----------|
| 03 漁獲努力量（1804~1903）（熊本県）.xls | kumamoto |
| 04 漁獲努力量（1704~1803）（熊本県）.xls | kumamoto |

#+TBLNAME: tbl_prefec_key
| prefec   | key.topleft |
|----------+-------------|
| nagasaki | FL(mm)      |


各県のファイル名を fmtbl() に与えると，データ形式に適した形で整形される．
水面下でデータ型式を読みに行き，ファイル名に属性として付与している

fname <- "04 漁獲努力量（1704~1803）（熊本県）.xls"



*** get_topleft(key = "FL(mm)")
** リロード & 自動テスト
#+BEGIN_SRC R :results output
  setwd("gyokaikyor")
  devtools::load_all()
  system("R CMD INSTALL --preclean --no-multiarch --with-keep.source .")
  devtools::test()
  devtools::document(roclets=c('rd', 'collate', 'namespace'))
#+END_SRC
** テストコード
:PROPERTIES:
:header-args: :results silent :exports code
:END:
*** テスト/ ファイル名操作
#+BEGIN_SRC R :tangle gyokaikyor/tests/testthat/test_handle_fname.R
  context("Handle file name")
  fn_kumamoto  <- "04 漁獲努力量（1704~1803）（熊本県）.xls"
  fn_kagoshima <- "体長組成(H29年度).xlsx"
  tbl_fname    <- hash::hash(c(fn_kumamoto, fn_kagoshima),
                             c("kumamoto", "kagoshima"))
  test_that("give_class() gives fname its file format as class", {
    expect_is(give_class(fn_kumamoto, tbl_fname), "list")
    expect_is(give_class(fn_kumamoto, tbl_fname)[[1]], "kumamoto")
    expect_is(give_class(fn_kagoshima, tbl_fname)[[1]], "kagoshima")
  })
#+END_SRC
*** テスト/ セル位置取得
#+BEGIN_SRC R :tangle gyokaikyor/tests/testthat/test_locate_cellpos.R
  context("Locate cell position")
  library(tibble)
  df <- tribble(~A, ~B, ~C, ~D,
                NA, NA, NA, 1,
                NA, "name", "value", 2,
                "", "foo", 12, 3,
                "", "bar", 123, 4,
                "", "baz", 1234, 5,
                "", "bum", 12345, 6,
                "", "foo", 12, 7)

  test_that("quot_ring() throws value on given quotient ring", {
    expect_equal(quot_ring(0, 3), 3)
    expect_equal(quot_ring(1, 3), 1)
    expect_equal(quot_ring(2, 3), 2)
    expect_equal(quot_ring(0, 5), 5)
    expect_equal(quot_ring(1, 5), 1)
    expect_equal(quot_ring(2, 5), 2)
    expect_equal(quot_ring(3, 5), 3)
    expect_equal(quot_ring(4, 5), 4)
  })

  test_that("quot2col() throws col position from
   quotient of given match position in matrix", {
    expect_equal(quot2col(3, 0), 3)
    expect_equal(quot2col(3, 1), 4)
    expect_equal(quot2col(4, 1), 5)
    expect_equal(quot2col(5, 1), 6)
    expect_equal(quot2col(5, 2), 6)
  })

  test_that("get_locate_patterns() locates cell position that has given regex", {
    expect_equal(locate_patterns(df, "name"), "$B$2")
    expect_equal(locate_patterns(df, "nam."), "$B$2")
    expect_equal(locate_patterns(df, "foo"), c("$B$3", "$B$7"))
  })

  test_that("get_topleft() locates cell position that has given regex", {
    expect_equal(get_topleft(df, "name"), "$B$2")
    expect_equal(get_topleft(df, "nam."), "$B$2")
    expect_equal(get_topleft(df, "foo"), "$B$3")
  })

  test_that("get_bottomright() locates cell position that has given regex", {
    expect_equal(get_bottomright(df, "12345"), "$C$6")
    expect_equal(get_bottomright(df, "foo"), "$B$7")
  })
  #+END_SRC
*** テスト/ 文字列操作
#+BEGIN_SRC R :tangle gyokaikyor/tests/testthat/test_handle_str.R
  context("Handle string")

  target <-
    c("漁獲年月日", "", "2017.4.20", "操業海域", "八代海", "漁法", "まき網",
    "漁獲年月日", "", "2017.5.19", "操業海域", "八代海", "漁法", "まき網",
    "漁獲年月日", "", "2017.6.23", "操業海域", "八代海", "漁法", "まき網")

  expect_equal(get_col2load(target,
                            regex = "20[0-9]{2}\\.[0-9][0-9]?\\.[0-9][0-9]?",
                            offset = -2),
               c(1, 8, 15))
#+END_SRC
** 関数
:PROPERTIES:
:header-args: :results silent :exports code
:END:
*** ファイル名操作
#+BEGIN_SRC R :tangle gyokaikyor/R/handle_fname.R
  give_classi   <- function(fname, prefec) {
    out        <- fname
    class(out) <- prefec
    out
  }

  #' @export
  give_class <- function(fname, tbl.fname) {
    prefec     <- hash::values(tbl.fname, keys = fname)
    out <- purrr::map2(fname, prefec, give_classi)
    out
  }
#+END_SRC
*** セル位置取得
#+BEGIN_SRC R :tangle gyokaikyor/R/locate_cellpos.R
  quot_ring <- function(mod, ideal) {
    if (mod == 0) {
      a <- ideal
    } else {
      a <- mod
    }
    a
  }

  quot2col <- function(quotient, mod) {
    if (mod == 0) {
      col <- quotient
    } else {
      col <- quotient + 1
    }
    col
  }

  make_RC <- function(row, col) {
    rc <- paste0("R", row, "C", col)
    rc
  }

  locate_patterns <- function(df, regex) {
    nrows <- dim(df)[1]
    ncols <- dim(df)[2]
    match <- apply(df, 2, gregexpr, pattern = regex) %>%
      unlist()
    pos <- which(match == TRUE)
    quo <- purrr::map(pos, `%/%`, nrows)
    mod <- purrr::map(pos, `%%`, nrows)
    col <- purrr::map2(quo, mod, quot2col)
    row <- purrr::map2(mod, nrows, quot_ring)
    rc  <- purrr::map2(row, col, make_RC)
    pos <- cellranger::R1C1_to_A1(paste0("R", row, "C", col))
    pos
  }

  get_topleft <- function(df, regex) {
    pos <- locate_patterns(df, regex)
    pos[1]
  }

  get_bottomright <- function(df, regex) {
    pos <- locate_patterns(df, regex)
    rev(pos)[1]
  }
  #+END_SRC
*** 文字列操作
#+BEGIN_SRC R :tangle gyokaikyor/R/handle_str.R
  get_col2load   <- function(target, regex, offset) {
    match <- stringr::str_detect(target, regex)
    out <- which(match == TRUE) + offset
    out
  }
#+END_SRC
*** 計測データ取得
#+BEGIN_SRC R :tangle gyokaikyor/R/get_measdata.R
  get_measdata <- function(df, col) {
    rows <- 8:107
    out  <- df[rows, col] %>%
      unlist() %>%
      as.numeric() %>%
      na.omit() %>%
      as.vector()
    out
  }
#+END_SRC
*** 整形
#+BEGIN_SRC R
  fmtbl <- function(fname, nest = FALSE) {
    UseMethod("fmtbl")
  }

  fmtbl.nagasaki  <- function(fname) {}
  fmtbl.kumamoto  <- function(fname, nest = TRUE) {
    out       <- list()
    suppressMessages(
      alldata   <- readxl::read_excel(fname,
                                      sheet = "カタクチ", col_names = FALSE)
    )
    cpos_date <- get_col2load(alldata[1,], regex = "[0-9]+", offset = 0)
    cpos_bl   <- cpos_date # Column position of "被鱗体長" is
                           #   same as that of "%Y.%m.%d" column
    date      <- alldata[1, cpos_date] %>%
      tinyplyr::jpdate2julian() %>%
      tinyplyr::num2date()
    method    <- alldata[1, cpos_date + 4] %>%
      unlist() %>%
      as.vector()
    bl        <- purrr::map(cpos_date, get_measdata, df = alldata)
    unlist(bl)

    out$date   <- date
    out$method <- method
    out$year   <- lubridate::year(out$date)
    out$month  <- lubridate::month(out$date)
    out$bl     <- bl

    out <- tibble::as_tibble(out)
    if (nest == FALSE) {
      out <- tidyr::unnest(out)
    }
    out
  }

#+END_SRC
