#+TITLE: reformr ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆãƒãƒ¼ãƒˆ
#+PROPERTY: header-args :session *R:tidyNAS*
* ç›®æ¬¡                                                                :TOC_3:
- [[#ã“ã‚Œã¯ä½•ã‹][ã“ã‚Œã¯ä½•ã‹ï¼Ÿ]]
- [[#ãƒ‘ãƒƒã‚±ãƒ¼ã‚¸èª­ã¿è¾¼ã¿][ãƒ‘ãƒƒã‚±ãƒ¼ã‚¸èª­ã¿è¾¼ã¿]]
- [[#ä½¿ã„æ–¹][ä½¿ã„æ–¹]]
  - [[#æ•´ç†å¯¾è±¡ãƒ‡ã‚£ãƒ¬ã‚¯ãƒˆãƒªã®æŒ‡å®š][æ•´ç†å¯¾è±¡ãƒ‡ã‚£ãƒ¬ã‚¯ãƒˆãƒªã®æŒ‡å®š]]
  - [[#ãƒ‡ãƒ¼ã‚¿ã‚’èª­ã¿è¾¼ã‚“ã§-csv-ã¨ã—ã¦æ›¸ãå‡ºã™][ãƒ‡ãƒ¼ã‚¿ã‚’èª­ã¿è¾¼ã‚“ã§ csv ã¨ã—ã¦æ›¸ãå‡ºã™]]
  - [[#æœªæ•´å½¢csvãƒ•ã‚¡ã‚¤ãƒ«ã‚’èª­ã¿è¾¼ã‚“ã§çµ±åˆ][æœªæ•´å½¢csvãƒ•ã‚¡ã‚¤ãƒ«ã‚’èª­ã¿è¾¼ã‚“ã§çµ±åˆ]]
    - [[#ãƒ‡ãƒ¼ã‚¿çµ±åˆ][ãƒ‡ãƒ¼ã‚¿çµ±åˆ]]
    - [[#ãƒ‡ãƒ¼ã‚¿ã®ç²¾æŸ»][ãƒ‡ãƒ¼ã‚¿ã®ç²¾æŸ»]]
- [[#ãƒ‘ãƒƒã‚±ãƒ¼ã‚¸é–‹ç™ºã®æº–å‚™][ãƒ‘ãƒƒã‚±ãƒ¼ã‚¸é–‹ç™ºã®æº–å‚™]]
  - [[#r-ãƒ‘ãƒƒã‚±ãƒ¼ã‚¸ã®é–‹ç™ºç’°å¢ƒã‚’æ•´ãˆã‚‹][R ãƒ‘ãƒƒã‚±ãƒ¼ã‚¸ã®é–‹ç™ºç’°å¢ƒã‚’æ•´ãˆã‚‹]]
  - [[#ä½¿ç”¨ã—ãŸãƒ‘ãƒƒã‚±ãƒ¼ã‚¸][ä½¿ç”¨ã—ãŸãƒ‘ãƒƒã‚±ãƒ¼ã‚¸]]
- [[#é–‹ç™º][é–‹ç™º]]
  - [[#å†ãƒ­ãƒ¼ãƒ‰--è‡ªå‹•ãƒ†ã‚¹ãƒˆ][å†ãƒ­ãƒ¼ãƒ‰ & è‡ªå‹•ãƒ†ã‚¹ãƒˆ]]
  - [[#ãƒ†ã‚¹ãƒˆã‚³ãƒ¼ãƒ‰][ãƒ†ã‚¹ãƒˆã‚³ãƒ¼ãƒ‰]]
    - [[#ãƒ†ã‚¹ãƒˆãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿ä½œæˆé–¢æ•°][ãƒ†ã‚¹ãƒˆ/ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿ä½œæˆé–¢æ•°]]
    - [[#ãƒ†ã‚¹ãƒˆæ–‡å­—åˆ—ãƒ‘ãƒ¼ã‚¹][ãƒ†ã‚¹ãƒˆ/æ–‡å­—åˆ—ãƒ‘ãƒ¼ã‚¹]]
    - [[#ãƒ†ã‚¹ãƒˆçµ±åˆãƒ†ã‚¹ãƒˆ][ãƒ†ã‚¹ãƒˆ/çµ±åˆãƒ†ã‚¹ãƒˆ]]
    - [[#ãƒ†ã‚¹ãƒˆãƒ‡ãƒ¼ã‚¿æ•´å½¢é–¢æ•°][ãƒ†ã‚¹ãƒˆ/ãƒ‡ãƒ¼ã‚¿æ•´å½¢é–¢æ•°]]
  - [[#é–¢æ•°å®šç¾©][é–¢æ•°å®šç¾©]]
    - [[#ãƒ¦ãƒ¼ãƒ†ã‚£ãƒªãƒ†ã‚£][ãƒ¦ãƒ¼ãƒ†ã‚£ãƒªãƒ†ã‚£]]
    - [[#æ–‡å­—åˆ—ãƒ‘ãƒ¼ã‚¹][æ–‡å­—åˆ—ãƒ‘ãƒ¼ã‚¹]]
    - [[#çµ±åˆé–¢æ•°][çµ±åˆé–¢æ•°]]
    - [[#reformindir-type][reform(indir, type)]]
    - [[#conv2entsheet][conv2entsheet()]]
    - [[#export_inputsheet][export_inputSheet()]]
- [[#ãƒ‡ãƒ¼ã‚¿æ•´å‚™çŠ¶æ³][ãƒ‡ãƒ¼ã‚¿æ•´å‚™çŠ¶æ³]]
  - [[#nas][NAS]]

* ã“ã‚Œã¯ä½•ã‹ï¼Ÿ
æµ®é­šè³‡æºã‚°ãƒ«ãƒ¼ãƒ—ã§ç”Ÿæˆã•ã‚ŒãŸãƒ‡ãƒ¼ã‚¿ã‚’æ•´å½¢ã™ã‚‹ãƒãƒƒã‚±ãƒ¼ã‚¸ï¼
ã€ŒåŸæœ¬ã‚’ãã‚Œã„ã«ä¿ã¤ã€ã“ã¨ã«ä¸»çœ¼ã‚’ç½®ã„ã¦ã„ã‚‹ï¼
ä¸€æ–¹ï¼Œå¤–éƒ¨æ©Ÿé–¢ã‹ã‚‰é€ä»˜ã•ã‚Œã‚‹ãƒ‡ãƒ¼ã‚¿ï¼ˆä¾‹ãˆã°ä»¥ä¸‹ï¼‰ã¯ï¼ŒåŸæœ¬ã‚’ãã‚Œã„ã«ã™ã‚‹ã“ã¨ã¯ã§ããªã„ãŸã‚ï¼Œ
ã“ã®ãƒ‘ãƒƒã‚±ãƒ¼ã‚¸ã§ã¯æ‰±ã‚ãªã„ï¼
- ãƒã‚¢ã‚¸é«˜ç²¾åº¦åŒ–ã®å³¶æ ¹ & é³¥å–ãƒ‡ãƒ¼ã‚¿: -> jmdatar ã§æ‰±ã†
- æ¼æµ·æ³å„çœŒãƒ‡ãƒ¼ã‚¿: -> gyokaikyo ã§æ‰±ã†

* ãƒ‘ãƒƒã‚±ãƒ¼ã‚¸èª­ã¿è¾¼ã¿
#+name: load-packages
#+BEGIN_SRC R :results silent
library(tidyverse)
library(lubridate)
library(readxl)
#+END_SRC
* ä½¿ã„æ–¹
** æ•´ç†å¯¾è±¡ãƒ‡ã‚£ãƒ¬ã‚¯ãƒˆãƒªã®æŒ‡å®š
#+BEGIN_SRC R :results output
  indir    <- "../data.git/é®®é­šé–¢ä¿‚/"
  outdir   <- "../output.git/"
  dirs_all <- list.files(indir, recursive = TRUE, full.names = TRUE) %>%
    utf8::utf8_normalize()
    dirs <- dirs_all[gregexpr(".+[ã‚«ã‚¿ã‚¯ãƒã‚¤ãƒ¯ã‚·|ãƒã‚¤ãƒ¯ã‚·|ãƒã‚¢ã‚¸]\\.xls", dirs_all) > 0]
  head(dirs)
  tail(dirs)
#+END_SRC

#+RESULTS:
#+begin_example
[1] "../data.git/é®®é­šé–¢ä¿‚//é®®é­šæ¸¬å®š06/ã‚«ã‚¿ã‚¯ãƒã‚¤ãƒ¯ã‚·.xls"
[2] "../data.git/é®®é­šé–¢ä¿‚//é®®é­šæ¸¬å®š06/ãƒã‚¢ã‚¸.xls"        
[3] "../data.git/é®®é­šé–¢ä¿‚//é®®é­šæ¸¬å®š06/ãƒã‚¤ãƒ¯ã‚·.xls"      
[4] "../data.git/é®®é­šé–¢ä¿‚//é®®é­šæ¸¬å®š07/ã‚«ã‚¿ã‚¯ãƒã‚¤ãƒ¯ã‚·.xls"
[5] "../data.git/é®®é­šé–¢ä¿‚//é®®é­šæ¸¬å®š07/ãƒã‚¢ã‚¸.xls"        
[6] "../data.git/é®®é­šé–¢ä¿‚//é®®é­šæ¸¬å®š07/ãƒã‚¤ãƒ¯ã‚·.xls"
[1] "../data.git/é®®é­šé–¢ä¿‚//é®®é­šæ¸¬å®š18/ã‚«ã‚¿ã‚¯ãƒã‚¤ãƒ¯ã‚·.xls"
[2] "../data.git/é®®é­šé–¢ä¿‚//é®®é­šæ¸¬å®š18/ãƒã‚¢ã‚¸.xls"        
[3] "../data.git/é®®é­šé–¢ä¿‚//é®®é­šæ¸¬å®š18/ãƒã‚¤ãƒ¯ã‚·.xls"      
[4] "../data.git/é®®é­šé–¢ä¿‚//é®®é­šæ¸¬å®š19/ã‚«ã‚¿ã‚¯ãƒã‚¤ãƒ¯ã‚·.xls"
[5] "../data.git/é®®é­šé–¢ä¿‚//é®®é­šæ¸¬å®š19/ãƒã‚¢ã‚¸.xls"        
[6] "../data.git/é®®é­šé–¢ä¿‚//é®®é­šæ¸¬å®š19/ãƒã‚¤ãƒ¯ã‚·.xls"
#+end_example
** ãƒ‡ãƒ¼ã‚¿ã‚’èª­ã¿è¾¼ã‚“ã§ csv ã¨ã—ã¦æ›¸ãå‡ºã™
ã“ã®æ®µéšã§ã¯ã¾ã æ•´å½¢ã¯ã—ãªã„ï¼
#+BEGIN_SRC R :results silent :exports code
  for (i in dirs) {
    infile <- i
    (sheetlist  <- readxl::excel_sheets(infile))
    (sheet2load <- filter_sheet(sheetlist))
    if(length(sheet2load) > 0) {
      data        <- purrr::map2(infile, sheet2load, readxl::read_excel)
      outfpath    <- paste0(outdir, "conv_from_xls/", make_outfname(infile))
      purrr::walk2(data, outfpath, readr::write_csv)
    }
  }
#+END_SRC


#+BEGIN_SRC sh :session nil :results output
cd output.git
git clean -f
#+END_SRC

#+RESULTS:
#+begin_example
bash: cd: output.git: No such file or directory
Removing ã‚¿ã‚¯ãƒã‚¤ãƒ¯ã‚·_0125.csv
Removing ã‚¿ã‚¯ãƒã‚¤ãƒ¯ã‚·_0204.csv
Removing ã‚¿ã‚¯ãƒã‚¤ãƒ¯ã‚·_0207(1).csv
Removing ã‚¿ã‚¯ãƒã‚¤ãƒ¯ã‚·_0217.csv
Removing ã‚¿ã‚¯ãƒã‚¤ãƒ¯ã‚·_0325.csv
Removing ã‚¿ã‚¯ãƒã‚¤ãƒ¯ã‚·_0407.csv
Removing ã‚¿ã‚¯ãƒã‚¤ãƒ¯ã‚·_0428.csv
Removing ã‚¿ã‚¯ãƒã‚¤ãƒ¯ã‚·_0510.csv
Removing ã‚¿ã‚¯ãƒã‚¤ãƒ¯ã‚·_0524.csv
Removing ã‚¿ã‚¯ãƒã‚¤ãƒ¯ã‚·_0929.csv
#+end_example
** æœªæ•´å½¢csvãƒ•ã‚¡ã‚¤ãƒ«ã‚’èª­ã¿è¾¼ã‚“ã§çµ±åˆ
ãƒ•ã‚¡ã‚¤ãƒ«åã‹ã‚‰æ¡é›†æ—¥ãªã©ã®æƒ…å ±ã‚’å–å¾—ã—ï¼Œmerged.csvã«çµ±åˆã™ã‚‹
merged.csv ã«ï¼Œå…ƒãƒ‡ãƒ¼ã‚¿ã«èµ·å› ã™ã‚‹ä¸å…·åˆãŒè¦‹ã¤ã‹ã£ãŸã‚‰ï¼Œxls ã‚’ä¿®æ­£ï¼Œã‚‚ã—ãã¯ã‚³ãƒ¼ãƒ‰ã‚’ä¿®æ­£ï¼
*** ãƒ‡ãƒ¼ã‚¿çµ±åˆ
#+BEGIN_SRC R
  dir_unformatted <- "../output.git/conv_from_xls"
  csvs_all <- list.files(dir_unformatted, full.names = TRUE)
  csv_anchovy  <- csvs_all[gregexpr("ã‚«ã‚¿ã‚¯ãƒã‚¤ãƒ¯ã‚·", csvs_all) > 0]

  my_readcsv <- function(fpath) {
    data <- read_csv(fpath) %>%
      mutate(original.file = fpath)
    data
  }
  anchovy <- purrr::map(csv_anchovy, my_readcsv) %>%
    bind_rows()

#+END_SRC
*** ãƒ‡ãƒ¼ã‚¿ã®ç²¾æŸ»
#+BEGIN_SRC R :results output
  colnames(anchovy)

  anchovy %>%
    filter(!is.na(No)) %>%
    select(original.file) %>%
    unique()


  anchovy %>%
    rename(foo = "..11") %>%
    filter(!is.na(foo)) %>%
    select(original.file) %>%
    unique()
#+END_SRC

#+RESULTS:
#+begin_example
 [1] "ç•ªå·"          "BL"            "BW"            "Sex"          
 [5] "GW"            "GSI(male)"     "GSI(Female)"   "original.file"
 [9] "No"            "ãƒ›ãƒ«ãƒãƒªãƒ³"    "è€³çŸ³"          "é±—"           
[13] "..11"          "å‚™è€ƒ"          "ç­‹è‚‰å†·å‡"      "FL"           
[17] "å†…è‡“é™¤å»é‡é‡"  "ã‚¢ãƒ‹ã‚µã‚­ã‚¹"    "SL"            "Gu"           
[21] "å°¾é°­"
[90m# A tibble: 100 x 1[39m
   original.file                                              
   [3m[90m<chr>[39m[23m                                                      
[90m 1[39m ../output.git/conv_from_xls/2006_ã‚«ã‚¿ã‚¯ãƒã‚¤ãƒ¯ã‚·_0325.csv   
[90m 2[39m ../output.git/conv_from_xls/2006_ã‚«ã‚¿ã‚¯ãƒã‚¤ãƒ¯ã‚·_0407.csv   
[90m 3[39m ../output.git/conv_from_xls/2006_ã‚«ã‚¿ã‚¯ãƒã‚¤ãƒ¯ã‚·_0428.csv   
[90m 4[39m ../output.git/conv_from_xls/2006_ã‚«ã‚¿ã‚¯ãƒã‚¤ãƒ¯ã‚·_0510.csv   
[90m 5[39m ../output.git/conv_from_xls/2006_ã‚«ã‚¿ã‚¯ãƒã‚¤ãƒ¯ã‚·_0524.csv   
[90m 6[39m ../output.git/conv_from_xls/2006_ã‚«ã‚¿ã‚¯ãƒã‚¤ãƒ¯ã‚·_0929.csv   
[90m 7[39m ../output.git/conv_from_xls/2007_ã‚«ã‚¿ã‚¯ãƒã‚¤ãƒ¯ã‚·_0110.csv   
[90m 8[39m ../output.git/conv_from_xls/2007_ã‚«ã‚¿ã‚¯ãƒã‚¤ãƒ¯ã‚·_0427(2).csv
[90m 9[39m ../output.git/conv_from_xls/2007_ã‚«ã‚¿ã‚¯ãƒã‚¤ãƒ¯ã‚·_0427.csv   
[90m10[39m ../output.git/conv_from_xls/2007_ã‚«ã‚¿ã‚¯ãƒã‚¤ãƒ¯ã‚·_0619.csv   
[90m# â€¦ with 90 more rows[39m
[90m# A tibble: 3 x 1[39m
  original.file                                             
  [3m[90m<chr>[39m[23m                                                     
[90m1[39m ../output.git/conv_from_xls/2007_ã‚«ã‚¿ã‚¯ãƒã‚¤ãƒ¯ã‚·_0619.csv  
[90m2[39m ../output.git/conv_from_xls/2007_ã‚«ã‚¿ã‚¯ãƒã‚¤ãƒ¯ã‚·_0619å¤§.csv
[90m3[39m ../output.git/conv_from_xls/2007_ã‚«ã‚¿ã‚¯ãƒã‚¤ãƒ¯ã‚·_0619å°.csv
#+end_example

* ãƒ‘ãƒƒã‚±ãƒ¼ã‚¸é–‹ç™ºã®æº–å‚™
** R ãƒ‘ãƒƒã‚±ãƒ¼ã‚¸ã®é–‹ç™ºç’°å¢ƒã‚’æ•´ãˆã‚‹
#+BEGIN_SRC R :results silent :exports code
# usethis::create_package("reformr")
# usethis::use_testthat()
setwd("reformr")
#+END_SRC
** ä½¿ç”¨ã—ãŸãƒ‘ãƒƒã‚±ãƒ¼ã‚¸
#+BEGIN_SRC R :results silent :exports code
usethis::use_package("magrittr", type = "Imports")
usethis::use_package("dplyr", type = "Imports")
usethis::use_package("lubridate", type = "Imports")
usethis::use_package("readxl", type = "Imports")
usethis::use_package("stringr", type = "Imports")
#+END_SRC

#+BEGIN_SRC sh :session nil :results output :exports results
cat reformr/DESCRIPTION
#+END_SRC

#+RESULTS:
#+begin_example
Package: reformr
Title: What the Package Does (One Line, Title Case)
Version: 0.0.0.9000
Authors@R: 
person(given = "First",
        family = "Last",
        role = c("aut", "cre"),
        email = "first.last@example.com")
Description: What the package does (one paragraph).
License: What license it uses
Encoding: UTF-8
LazyData: true
Suggests: 
testthat
Imports: 
magrittr,
dplyr,
lubridate,
readxl
#+end_example
* é–‹ç™º
** å†ãƒ­ãƒ¼ãƒ‰ & è‡ªå‹•ãƒ†ã‚¹ãƒˆ
#+BEGIN_SRC R :exports both :results silent
  devtools::load_all()
  system("R CMD INSTALL --preclean --no-multiarch --with-keep.source .")
  devtools::test()
  devtools::document(roclets=c('rd', 'collate', 'namespace'))
#+END_SRC

** ãƒ†ã‚¹ãƒˆã‚³ãƒ¼ãƒ‰
*** ãƒ†ã‚¹ãƒˆ/ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿ä½œæˆé–¢æ•°
#+begin_src r :tangle reformr/tests/testthat/test_param.R
  # library(tidyverse)
  #   context("Handle param object")
  #   test_that("make_params accept only 'sengyo' or 'cruise'", {
  #     expect_error(make_params(indir = "./", "a")
  #                , "Tell me the correct type of data. is it 'sengyo', or 'cruise?'", fixed = TRUE)
  #     expect_error(make_params(indir = "./", 1),
  #                  "Tell me the correct type of data. is it 'sengyo', or 'cruise?'", fixed = TRUE)
  #   })
  #   test_that("make_params accept only 'ã‚«ã‚¿ã‚¯ãƒã‚¤ãƒ¯ã‚·', 'ãƒã‚¤ãƒ¯ã‚·' or 'ãƒã‚¢ã‚¸' ", {
  #     expect_error(make_params(indir = "./", "sengyo", 1), "Tell me the correct japanese species name.", fixed = TRUE)
  #     expect_error(make_params(indir = "./", "sengyo", "anchovy"),  "Tell me the correct japanese species name.", fixed = TRUE)
  #   })
#+END_SRC

*** ãƒ†ã‚¹ãƒˆ/æ–‡å­—åˆ—ãƒ‘ãƒ¼ã‚¹
#+BEGIN_SRC R :tangle reformr/tests/testthat/test_parse_str.R
  context("Parse strings")

  test_that("parse_year() puts year list correctly", {
    expect_match(parse_year("é®®é­šæ¸¬å®š11"), "2011")
    expect_match(parse_year("é®®é­šæ¸¬å®š99"), "2099")
    expect_equal(parse_year("aaaa99"), NA)
    expect_equal(parse_year("____99"), NA)
    expect_equal(parse_year("123499"), NA)
  })

  # test_that("get_date() parses dates correctly", {
  #   expect_equal(get_date(2012, "0201"), as.Date("2012-02-01"))
  #   expect_equal(get_date(2012, "0201(1)"), as.Date("2012-02-01"))
  #   expect_equal(get_date(2017, "170201(1)"), as.Date("2017-02-01"))
  #   expect_equal(get_date(2017, "170201(11)"), as.Date("2017-02-01"))
  # })

  test_that("get_spcsname() gets spcs name", {
    expect_equal(get_spcsname("ã‚«ã‚¿ã‚¯ãƒã‚¤ãƒ¯ã‚·.xls"), "ã‚«ã‚¿ã‚¯ãƒã‚¤ãƒ¯ã‚·")
    expect_equal(get_spcsname("ã‚«ã‚¿ã‚¯ãƒ.xls"), "ã‚«ã‚¿ã‚¯ãƒã‚¤ãƒ¯ã‚·")
    expect_equal(get_spcsname("ã‚«ã‚¿ã‚¯ãƒ.xls"), "ã‚«ã‚¿ã‚¯ãƒã‚¤ãƒ¯ã‚·")
    goodnames <- c("ã‚«ã‚¿ã‚¯ãƒã‚¤ãƒ¯ã‚·", "ãƒã‚¤ãƒ¯ã‚·", "ãƒã‚¢ã‚¸", "ã‚¦ãƒ«ãƒ¡ã‚¤ãƒ¯ã‚·")
    variants  <- c("ã‚«ã‚¿ã‚¯ãƒã‚¤ãƒ¯ã‚·", "ã‚«ã‚¿ã‚¯ãƒ", "ãƒã‚¤ãƒ¯ã‚·", "ãƒã‚¢ã‚¸",
                   "ã‚¦ãƒ«ãƒ¡ã‚¤ãƒ¯ã‚·", "ã‚¦ãƒ«ãƒ¡")
    misc      <- c("æ¸¬å®š", "é³¥å–", "XXä¸¸", "")
    xtn       <- c(".xls", ".xlsx")
    fnames    <- expand.grid(variants, misc, xtn) %>%
      dplyr::transmute(fname = paste0(Var1, Var2, Var3)) %>%
      dplyr::pull(fname)
    expect_setequal(purrr::map(variants, get_spcsname) %>%
                      unlist() %>%
                      unique(),
                    goodnames)
  })

  test_that("filter_sheet() gets sheets with good name format", {
    expect_equal(filter_sheet("0201"), "0201")
    expect_equal(filter_sheet("0201(1)"), "0201(1)")
    expect_equal(filter_sheet("0201å¤§"), "0201å¤§")
    expect_equal(length(filter_sheet("ä½“é•·")), 0)
    expect_equal(length(filter_sheet("Sheet1")), 0)
    sheets <- c("ä½“é•·", "0125", "0204", "0207(1)", "0217", "0325", "0407",
                "0428", "0510", "0524", "0929", "Sheet2", "Sheet3")
    expect <- c("0125", "0204", "0207(1)", "0217", "0325", "0407",
                "0428", "0510", "0524", "0929")
    expect_setequal(filter_sheet(sheets), expect)
  })

  test_that("parse_date() makes date from sheetname vector", {
    expect_equal(parse_date(2012, "0125"), "2012-01-25")
    expect_equal(parse_date(2016, "0204"), "2016-02-04")
  })
#+END_SRC
*** ãƒ†ã‚¹ãƒˆ/çµ±åˆãƒ†ã‚¹ãƒˆ 
#+BEGIN_SRC R :results silent :exports code :tangle reformr/tests/testthat/test_integrated.R
  context("Integrated test")

  test_that("make_outfname() creates out fname", {
    path   <- "../../../data.git/é®®é­šé–¢ä¿‚/é®®é­šæ¸¬å®š06/ã‚«ã‚¿ã‚¯ãƒã‚¤ãƒ¯ã‚·.xls"
    sheets <- c("0125", "0204", "0207(1)", "0217", "0325", "0407", "0428",
                "0510", "0524", "0929")
    mmdd   <- purrr::map(sheets, filter_sheet) %>% unlist()
    year   <- 2006
    spcs   <- "ã‚«ã‚¿ã‚¯ãƒã‚¤ãƒ¯ã‚·"
    xtn    <- ".csv"
    expect <- paste0(year, "_", spcs, "_", mmdd, xtn)
    expect_equal(make_outfname(path), expect)
  })

  # test_that("get_sheet2read() puts sheets to read", {
  #   expect_match(get_sheet2read(infile06), "0125", all = FALSE)
  #   expect_match(get_sheet2read(infile06), "0207", all = FALSE)
  #   expect_equal(length(get_sheet2read(infile06)), 10)
  #   expect_equal(length(get_sheet2read(infile17)), 0)
  # })

  # test_that("make_datlist make data list correctly", {
  #   expect_match(make_datlist(indir, type), "é®®é­šæ¸¬å®š06", all = FALSE)
  #   expect_match(make_datlist(indir, type), "é®®é­šæ¸¬å®š07", all = FALSE)
  # })

  # test_that("get_filelist() puts species file list correctly", {
  #   expect_match(get_filelist(indir, "ã‚«ã‚¿ã‚¯ãƒã‚¤ãƒ¯ã‚·"), "ã‚«ã‚¿ã‚¯ãƒã‚¤ãƒ¯ã‚·.xls", all = FALSE)
  #   expect_match(get_filelist(indir, "ãƒã‚¤ãƒ¯ã‚·"), "ãƒã‚¤ãƒ¯ã‚·.xls", all = FALSE)
  #   expect_error(get_filelist(indir), "argument \"spcs\" is missing, with no default", fixed = TRUE)
  #   expect_error(get_filelist(indir, NA), "Give me Japanese species name", fixed = TRUE)
  # })
#+END_SRC
*** ãƒ†ã‚¹ãƒˆ/ãƒ‡ãƒ¼ã‚¿æ•´å½¢é–¢æ•°
#+BEGIN_SRC R :tangle reformr/tests/testthat/test_format.R :results silent
  # library(tidyverse)
  # context("Formatting loaded data")
  # param <- list()
  # indir <- "/Users/ahayashi/Documents/GitHub/tidyNAS/data/é®®é­šé–¢ä¿‚/"
  # type  <- "sengyo"
  # spcs  <- "ã‚«ã‚¿ã‚¯ãƒã‚¤ãƒ¯ã‚·"
  # # get_filelist(param)
  # col_names <- c("sample.no", "bl_mm", "bw_g", "sex", "gw_g", "gsi", "otolith.taken", "original.fname", "original.sheetname")
  # # get_sheet2read(infile)
  # test_that("format() make datcols correctly", {
  #   expect_equal(length(colnames(format(paste0(indir, "é®®é­šæ¸¬å®š06/ã‚«ã‚¿ã‚¯ãƒã‚¤ãƒ¯ã‚·.xls"), "0125"))), length(col_names))
  #   expect_equal(length(colnames(format(paste0(indir, "é®®é­šæ¸¬å®š06/ã‚«ã‚¿ã‚¯ãƒã‚¤ãƒ¯ã‚·.xls"), "0325"))), length(col_names))
  #   expect_equal(length(colnames(format(paste0(indir, "é®®é­šæ¸¬å®š08/ãƒã‚¤ãƒ¯ã‚·.xls"), "0116"))), length(col_names))
  #   expect_equal(length(colnames(format(paste0(indir, "é®®é­šæ¸¬å®š08/ãƒã‚¤ãƒ¯ã‚·.xls"), "0117"))), length(col_names))
  #   expect_equal(colnames(format(paste0(indir, "é®®é­šæ¸¬å®š06/ã‚«ã‚¿ã‚¯ãƒã‚¤ãƒ¯ã‚·.xls"), "0125")), col_names, ignore.case = FALSE)
  #   expect_equal(colnames(format(paste0(indir, "é®®é­šæ¸¬å®š08/ãƒã‚¤ãƒ¯ã‚·.xls"), "0116")), col_names, ignore.case = FALSE)
  #   expect_equal(colnames(format(paste0(indir, "é®®é­šæ¸¬å®š08/ãƒã‚¤ãƒ¯ã‚·.xls"), "0117")), col_names, ignore.case = FALSE)
  # })

  # test_that("format() cleanses length and weight columns correctly", {
  #   expect_match(typeof(format(paste0(indir, "é®®é­šæ¸¬å®š06/ã‚«ã‚¿ã‚¯ãƒã‚¤ãƒ¯ã‚·.xls"), "0125")$sample.no), "integer")
  #   expect_match(typeof(format(paste0(indir, "é®®é­šæ¸¬å®š06/ã‚«ã‚¿ã‚¯ãƒã‚¤ãƒ¯ã‚·.xls"), "0125")$bl_mm), "double")
  #   expect_match(typeof(format(paste0(indir, "é®®é­šæ¸¬å®š06/ã‚«ã‚¿ã‚¯ãƒã‚¤ãƒ¯ã‚·.xls"), "0125")$bw_g), "double")
  #   expect_match(typeof(format(paste0(indir, "é®®é­šæ¸¬å®š06/ã‚«ã‚¿ã‚¯ãƒã‚¤ãƒ¯ã‚·.xls"), "0125")$sex), "integer")
  #   expect_match(typeof(format(paste0(indir, "é®®é­šæ¸¬å®š06/ã‚«ã‚¿ã‚¯ãƒã‚¤ãƒ¯ã‚·.xls"), "0125")$gw_g), "double")
  #   expect_match(typeof(format(paste0(indir, "é®®é­šæ¸¬å®š06/ã‚«ã‚¿ã‚¯ãƒã‚¤ãƒ¯ã‚·.xls"), "0125")$gsi), "double")
  #   expect_match(typeof(format(paste0(indir, "é®®é­šæ¸¬å®š06/ã‚«ã‚¿ã‚¯ãƒã‚¤ãƒ¯ã‚·.xls"), "0325")$sample.no), "integer")
  #   expect_match(typeof(format(paste0(indir, "é®®é­šæ¸¬å®š06/ã‚«ã‚¿ã‚¯ãƒã‚¤ãƒ¯ã‚·.xls"), "0325")$bl_mm), "double")
  #   expect_match(typeof(format(paste0(indir, "é®®é­šæ¸¬å®š06/ã‚«ã‚¿ã‚¯ãƒã‚¤ãƒ¯ã‚·.xls"), "0325")$bw_g), "double")
  #   expect_match(typeof(format(paste0(indir, "é®®é­šæ¸¬å®š06/ã‚«ã‚¿ã‚¯ãƒã‚¤ãƒ¯ã‚·.xls"), "0325")$sex), "integer")
  #   expect_match(typeof(format(paste0(indir, "é®®é­šæ¸¬å®š06/ã‚«ã‚¿ã‚¯ãƒã‚¤ãƒ¯ã‚·.xls"), "0325")$gw_g), "double")
  #   expect_match(typeof(format(paste0(indir, "é®®é­šæ¸¬å®š06/ã‚«ã‚¿ã‚¯ãƒã‚¤ãƒ¯ã‚·.xls"), "0325")$gsi), "double")
  # })
  # test_that("format() cleanses otolith and scale columns correctly", {
  #   expect_match(typeof(format(paste0(indir, "é®®é­šæ¸¬å®š06/ã‚«ã‚¿ã‚¯ãƒã‚¤ãƒ¯ã‚·.xls"), "0125")$otolith.taken), "integer")
  # })
#+END_SRC

** é–¢æ•°å®šç¾©
*** ãƒ¦ãƒ¼ãƒ†ã‚£ãƒªãƒ†ã‚£
#+BEGIN_SRC R :tangle reformr/R/util.R
  #' @importFrom magrittr %>%
  #' @export
  magrittr::`%>%`
#+END_SRC
*** æ–‡å­—åˆ—ãƒ‘ãƒ¼ã‚¹
#+BEGIN_SRC R :results silent :exports code :tangle reformr/R/parse_str.R
  return_match <- function(x, regex) {
    match <- x %>%
      stringr::str_match(regex)
    out <- match[,2] %>%         # '2' points $1 regex capture
      na.omit() %>% as.vector()
    out
  }

  filter_sheet <- function(x) {
    re_omit  <- "^(?!.*0000)(?!ä½“é•·)(?!Sheet)"
    re_match <- "((?:0[1-9][0-9]{2}|1[0-2][0-9]{2}).*)"
    regex <- paste0(re_omit, re_match)
    out   <- return_match(x, regex)
    out
  }

  parse_year <- function(x) {
    regex <- "^é®®é­šæ¸¬å®š([0-9]{2})$"
    match <- return_match(x, regex)
    if (length(match) == 0) {
      out <- NA
    } else {
      out <- paste0(20, match)
    }
    out
  }

  parse_date <- function(year, mmdd) {
    mm  <- substr(mmdd, 1, 2)
    dd  <- substr(mmdd, 3, 4)
    out <- paste(year, mm, dd, sep = "-")
    out
  }

  get_spcsname <- function(x) {
    regex <- "(ã‚«ã‚¿ã‚¯ãƒ|ãƒ(?!ã‚¢ã‚¸)|ã‚¦ãƒ«ãƒ¡|ãƒã‚¢ã‚¸)"
    match <- return_match(x, regex)
    if (length(match) == 0) {
      out <- NA
    } else {
      switch(match,
             "ãƒã‚¢ã‚¸" = out <- match,
             out <- paste0(match, "ã‚¤ãƒ¯ã‚·"))
    }
    out
  }

  parse_str <- function(x, type) {
    switch(type,
           "sheet" = out <- filter_sheet(x),
           "year"  = out <- parse_year(x),
           "fish"  = out <- get_spcsname(x),
           stop("unknown case"))
    out
  }

#+END_SRC
*** çµ±åˆé–¢æ•°
#+BEGIN_SRC R :results silent :exports code :tangle reformr/R/integrated.R
  make_outfname <- function(fpath) {
    dirvec <- stringr::str_split(fpath, "/") %>%
      unlist()
    year     <- purrr::map2(dirvec, "year", parse_str) %>%
      unlist() %>% na.omit()
    spcsname <- purrr::map2(dirvec, "fish", parse_str) %>%
      unlist() %>% na.omit()
    sheetname <- readxl::excel_sheets(fpath) %>%
      filter_sheet()
    mmdd      <- filter_sheet(sheetname)
    out   <- paste0(year, "_", spcsname, "_", mmdd, ".csv")
    out
  }
#+END_SRC
*** reform(indir, type)
#+BEGIN_SRC R :tangle reformr/R/reform.R
  # This script is tangled from reformr.org.
  # Do not edit by hand!!!
  make_params <- function(indir, type, spcs){
    spcs_list <- c("ã‚«ã‚¿ã‚¯ãƒã‚¤ãƒ¯ã‚·", "ãƒã‚¤ãƒ¯ã‚·", "ãƒã‚¢ã‚¸")
    param <- list()
    if (type %in% c("sengyo", "cruise") == TRUE) {
      param$type = type
    } else {
      stop("Tell me the correct type of data. Is it 'sengyo', or 'cruise?'")
    }
    if (spcs %in% spcs_list) {
      param$spcs <- spcs
    } else {
      stop("Tell me the correct Japanese species name.")
    }
    param$indir <- indir
    param
  }
  make_datlist <- function(indir, type){
    if (type == "sengyo") {
      datlist <- list.files(indir, pattern = "é®®é­š")
    }
    datlist
  }


  get_filelist <- function(indir, spcs) {
    if (is.na(spcs)) {
      stop("Give me Japanese species name")
    } else {
      regexp   <- paste0(spcs, ".+")
    }
    filelist <- list.files(indir, pattern = regexp, recursive = TRUE, full.names = TRUE)
    filelist
  }

  get_sheet2read <- function(infile) {
    all_sheets <- readxl::excel_sheets(infile)
    sheets2read <- as.vector(na.omit(stringr::str_match(all_sheets, "^(?!.*0000)(?!ä½“é•·)(?!Sheet).+")))
    sheets2read
  }
  # get_date <- function(year, sheetname) {
  #   date_char <- dplyr::if_else(str_length(sheetname) >= 9,
  #                        paste0(20, str_sub(sheetname, 1, 6)),
  #                        paste0(year, str_sub(sheetname, 1, 4)))
  #   date      <- lubridate::ymd(date_char)
  #   date
  # }

  format <- function(infile, sheet) {
    data_org <- readxl::read_xls(infile, sheet = sheet)
    col_names <- colnames(data_org)
    if (col_names[1] == "ç•ªå·") data_org <- rename(data_org, No = "ç•ªå·")
    if (any(regexpr("è€³çŸ³", col_names) >0 ) == FALSE) data_org <- mutate(data_org, è€³çŸ³ = 0)
    data <- data_org %>%
      transmute(sample.no = parse_integer(No),
                bl_mm = parse_double(BL),
                bw_g = parse_double(BW),
                sex = parse_integer(Sex),
                gw_g = parse_double(GW),
                gsi = gw_g / bw_g * 100,
                otolith.taken = è€³çŸ³ %>%
                  str_replace("y", "1") %>%
                  parse_integer()) %>%
      mutate(original.fname = infile,
             original.sheetname = sheet)
    data
  }
#+END_SRC

#+RESULTS:

**** ã‚³ãƒ¼ãƒ‰ã‚’æ›¸ã
**** get_station()
**** format(param)
**** merge_old(param)
*** conv2entsheet()
**** load_tidied(data)
**** conv2inputSheet(tidied)
*** export_inputSheet()
**** load_inputSheet(entsheet)
**** split_year(inputSheet)
**** export_entsheet(entsheet, outdir)

* ãƒ‡ãƒ¼ã‚¿æ•´å‚™çŠ¶æ³
** NAS
